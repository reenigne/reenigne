World coordinates: 8.8   -128 <= model.x < 128
Matrix elements: 8.8     -128 <= _xx < 128
r.x and r.y: 16.16       -32768 <= r.x < 32768
r.z: 0 8.16              -128 <= r.z < 128

In current span, the s vector is 338, 282, 0.566
So the matrix elements won't fit in 8.8
  This just means that the model and screen need to be larger by at least a factor of 3
    Making the screen 4x3 in world units is quite nice!

The transformed (screen) coordinates should be accurate to 1/256 of pixel width
However, we want to allow for vertex positions which are a long way offscreen (e.g. above player)
Therefore, pre-clipping we want screen positions in 24.8 format
  Or 12.4?

Suppose transformed coordinates are in 16.16 format.

To compute 16.16 / 16.16, need to shift quotient rep left by x bits and divisor right by 16-x bits
  So could be a 48/32 division or a 32/16
  Latter would be much faster!
  This is x/(z >> 16) - i.e. drop fractional part of z
  However, we only want 8 fractional bits for fillTriangle, so we need a >>8
    So we could compute:
      (x >> 8)/(z >> 16) - 32/16 (really 24/16)
      x/(z >> 8) - 32/24 (can compute as 32/16 if -128 <= r.z < 128)
  We do need the transform output to be 16.8 or 24.8 in order to do clipping properly
    So use 32/16->32, which is two 32/16->16 operations
      xor dx,dx
      mov cx,[rz + 1]
      mov ax,[rx + 2]
      idiv cx          ; dx = remainder, ax = quotient
      mov [sx + 2],ax
      mov ax,[rx]
      idiv cx
      mov [sx],ax




For fillTriangle, we want a 24.8 result - i.e. vR = rR*2^-8

We have vX = rX*2^-16 and vZ = rZ*2^-16

vR = vX/vZ

rR*2^-8 = rX / rZ
rR = rX*2^8 / rZ

Suppose we want to compute this with a 32/16 divide



Suppose we have rX in DX:AX and rZ in BX:CX

mov ch,bl
mov cl,ch
idiv cx


(6*100*s/5) * 5 = 128  s = 0.21333  2/s = size of screen vertically in world coords = 9.375
size of screen horizontally = 10
this is with distance = 5 which is a very wide field of vision
  For a PC game, a 90 degree FoV is normal, i.e. distance = 128 pixels



Express FoV as distance in units of screen width (d/sx)
  FoV of 90 degrees is d/sx = 0.5 = ds    d = ds*sx     sx = d/ds

sx/sy = (5/6)*(256/200) = 1.06666     sx = 1.06666*sy   sy = 0.9375*sx
1/zs = sy/2      zs = 2/sy   sy = 2/zs
ys = 100*zs      zs = ys/100
xs = 6*ys/5      5*xs/6 = ys
xs*d = 128       xs = 128/d


sy = 2/zs = 2/(ys/100) = 200/ys     = pixels per world-unit vertically
sy = 200/(5*xs/6) = 200/(5*(128/d)/6) = 200/(5*(128/(ds*sx))/6) = 200/(5*(128/(ds*(1.06666*sy)))/6)

1/2 = ds


maximum matrix value = xs*d = 6*ys*d/5 = 6*100*(2/sy)*d/5  = 6*100*(2/(0.9375*(d/ds)))*d/5 = 256*ds

Want zs = 1 so sy = 2 and sx = 2.13333333
ys = 100
xs = 120
d = 1.06666


Modify distance to satisfy xs*d = 128

d = 128/xs = 128/(6*ys/5) = 128/(6*(100*zs)/5) = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d*d = 1.066666666*sqrt((d*d + 1)*3)

d^4 = 1.066666^2 * (d*d + 1)*3

d = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d = (4/5)*sqrt((8/3) + sqrt(139)/3) = 2.0547091212166765333819588893295

With ys = 99.5*zs, d = 2.06338



cos(a)*cos(b) = (cos(a + b) + cos(a - b))/2
sin(a)*sin(b) = (cos(a - b) - cos(a + b))/2
sin(a)*cos(b) = (sin(a + b) + sin(a - b))/2
cos(a)*sin(b) = (sin(a + b) - sin(a - b))/2


d = 8/15

r = (8/15)/sqrt(3*(1 + 8*8/(15*15)))


sin(u) = 1/256, u ~= 1/256    2048 entries, 2560 with cosines



MUL with byte arguments: 69 cycles plus 1 for each set bit in AL plus 1 if the high byte of the result is 0
MUL with word arguments: 123 cycles plus 1 for each set bit in AX plus 1 if the high word of the result is 0
IMUL with byte arguments: >= 80 cycles
IMUL with word arguments: >= 134 cycles

MUL rb                  69-78
IMUL rb                 80-98
DIV rb                  80-90
IDIV rb                101-112
MUL rw                 118-133
IMUL rw                128-154    141
DIV rw                 144-162
IDIV rw                165-184    175

1 vertex = 8 IMULs and 4 IDIVs = 1828 cycles
20 vertices = 36560 cycles = 120 scanlines
1 triangle = 3 IMULs and 3 IDIVs = 948 cycles
18 triangles = 17064 cycles = 56 scanlines

The


As sine table values are essentially 8 bits plus a sign bit, can we use table-of-squares to do the multiply?

(0x100*a + b)*c = (b*c) + 0x100*(a*c)

Assume value in sine table is in range 0..0xff
  mov si,[sineTable + di]                      ; 4 2
  mov bl,[modelCoord]                          ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov ax,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub ax,[si+bx]                               ; 2 2
  mov bl,[modelCoord + 1]                      ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov cx,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub cx,[si+bx]                               ; 2 2
  mov dl,ch                                    ; 2
  mov dh,0                                     ; 2
  mov ch,cl                                    ; 2
  mov cl,0                                     ; 2
  add ax,cx                                    ; 2
  adc dx,0                                     ; 3      228
No advantage in using half-square tables for full-range 16x8 bit multiplies



  mov ax,[modelCoord]                          ; 20
  imul word[sineTable + ...]                   ; result in dx:ax     134


Is it better to include the world-to-pixel scaling factors into the transformation matrix or apply them separately afterwards?
  Applying them separately doesn't seem to buy us anything, unless we can do crazy optimizations to eliminate the first mul (store separate sine table for each possible world position)
    world (8.8) * rotation (1.8) >> 8 -> rotated (8.8)            imul
    rotated (8.8) <<8 / z (8.8) -> transformed (24.8)          idiv idiv    need 32 bits of precision after perspective applied
    transformed (24.8) * scale (8.8) -> scaled (16.16)            imul

  Applying them together:
    world (8.8) * matrix (8.8) -> worldpix (16.16)   imul
    scaled (16.16) / z (8.8) -> screen (24.8)        idiv idiv


What if a triangle crosses z=0 and is partially visible?
  Need to draw an external triangle (figure 3 in https://www.cs.unc.edu/~olano/papers/2dh-tri/)



New span covers only one old span
  If co != cn
    xlo == xln, xro == xrn - New span covers old span exactly  - no shuffle
    xlo == xln, xro > xrn  - New span covers left of old span  - shuffle right 1
    xlo < xln,  xro == xrn - New span covers right of old span - shuffle right 1
    xlo < xln, xro > xrn   - New span within old span          - shuffle right 2
  else nothing to do
New span covers two old spans

1111111222222222333333333
AaaaaaaBbbbbbbbbCcccccccc




rep stosb to cga = 4 IOs per byte       (28 IOs for 7 bytes)
rep stosw to cga = 3.4285 IOs per byte  (24 IOs for 7 bytes)

mov ah,al
shr cx,1

	movb	%al,	%ah
	shrw	$1,	%cx
	rep	stosw
	adcw	%cx,	%cx
	rep	stosb

~14 bytes needed for longer version to be better




0x000000ea  y == 0x21

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:

0x001ADDFC  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x001ADE0C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x001ADE1C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x001ADE2C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0 (incorrect):

0x0044DCB4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0044DCC4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0044DCD4  55 55 55 00 00 00 00 00 00 00 00 54 00 00 00 00  UUU........T....
0x0044DCE4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2 (correct):

0x004473D4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004473E4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004473F4  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x00447404  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

Iteration:

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0x2d, xRn = 0x8d, co = 0x00, cn = 0x55
queuedStores = 0x00

x = 0x2d, xRo = 0xaf, xRn = 0x8d, co = 0x55, cn = 0x55
queuedSkips = 0x23

Need to create the partial byte 0x40 in here somehow

x = 0x8d, xRo = 0xaf, xRn = 0xff, co = 0x55, cn = 0x00
queuedStores = 0x08
vram = 0x23, queuedSkips = 0x00

x = 0xaf, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00
queuedSkips = 0x14                                      we're skipping
memset(offset = 0x23, value = 0x00, count = 0x08), queuedStores = 0










0x000000ea  y == 0x21

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:

0x0018E14C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018E15C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018E16C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x0018E17C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0 (incorrect):

0x0018E14C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018E15C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018E16C  55 55 55 40 00 00 00 00 00 00 00 54 00 00 00 00  UUU@.......T....
0x0018E17C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2 (correct):

0x0018786C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018787C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018788C  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x0018789C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0xaf, xRn = 0x8d, co = 0x55, cn = 0x55
queuedSkips = 0x23

x = 0x8d, xRo = 0xaf, xRn = 0xff, co = 0x55, cn = 0x00
vram = 0x23, queuedSkips = 0
*vram = 0x40, vram = 0x24, x = 0x90
queuedStores = 7

x = 0xaf, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00




0x0000013a  y == 0x70

old: 00 00 2d 55 d1 00 ff
new: 00 00 2d 55 d0 00 ff

Previous:

0x004CECE4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004CECF4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED04  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED14  55 55 55 55 40 00 00 00 00 00 00 00 00 00 00 00  UUUU@...........

vram0 (incorrect):

0x004CECE4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004CECF4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED04  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED14  55 55 55 55 40 00 00 00 00 00 00 00 00 00 00 00  UUUU@...........

vram2 (correct):

0x004C7784  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004C7794  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004C77A4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004C77B4  55 55 55 55 00 00 00 00 00 00 00 00 00 00 00 00  UUUU............

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0xd1, xRn = 0xd0, co = 0x55, cn = 0x55
queuedSkips = 0x33 (should be 34? - need to keep "start of skip" as a pixel rather than queuedSkips as a byte)

x = 0xd0, xRo = 0xd1, xRn = 0xff, co = 0x55, cn = 0x00
queuedStores = 0
partial = 0, havePartial = true

x = 0xd1, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00
queuedSkips = 0x3e (but we should have dealt with that partial before doing that)
*vram = 0x00 (writes at vram = 0)






                //if (xRo < xRn) {
                //    if (co == cn) {
                //        queuedSkips += (xRo - x) >> 2;
                //        if (queuedSkips > 0 && queuedStores > 0) {
                //            memset(vram, cn, queuedStores);
                //            vram += queuedStores;
                //            queuedStores = 0;
                //        }
                //    }
                //    else {
                //        if ((x & 3) != 0) {
                //            if (havePartial) {
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    if (queuedSkips > 0) {
                //                        vram += queuedSkips;
                //                        queuedSkips = 0;
                //                    }
                //                    *vram = partial | (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                    havePartial = false;
                //                }
                //                else {
                //                    partial |= cn &
                //                        mask[x & 3] & ~mask[xRn & 3];
                //                }
                //            }
                //            else {
                //                if (queuedSkips > 0) {
                //                    vram += queuedSkips;
                //                    queuedSkips = 0;
                //                }
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    *vram = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                }
                //                else {
                //                    partial = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                //                    havePartial = true;
                //                }
                //            }
                //        }
                //        queuedStores += (xRo - x) >> 2;
                //        if (queuedStores > 0 && queuedSkips > 0) {
                //            vram += queuedSkips;
                //            queuedSkips = 0;
                //        }
                //        if ((xRn & 3) != 0) {
                //            if ((xRn & 0xfc) > (x & 0xfc))
                //                partial = cn & ~mask[xRn & 3];
                //            else {
                //                partial = (*vram & ~mask[x & 3]) |
                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                //            }
                //            havePartial = true;
                //        }
                //    }
                //    x = xRo;
                //    co = so->_c;
                //    ++so;
                //    xRo = so->_x;
                //}
                //else {
                //    if (co == cn) {
                //        queuedSkips += (xRn - x) >> 2;
                //        if (queuedSkips > 0 && queuedStores > 0) {
                //            memset(vram, cn, queuedStores);
                //            vram += queuedStores;
                //            queuedStores = 0;
                //        }
                //    }
                //    else {
                //        if ((x & 3) != 0) {
                //            if (havePartial) {
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    if (queuedSkips > 0) {
                //                        vram += queuedSkips;
                //                        queuedSkips = 0;
                //                    }
                //                    *vram = partial | (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                    havePartial = false;
                //                }
                //                else {
                //                    partial |= cn &
                //                        mask[x & 3] & ~mask[xRn & 3];
                //                }
                //            }
                //            else {
                //                if (queuedSkips > 0) {
                //                    vram += queuedSkips;
                //                    queuedSkips = 0;
                //                }
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    *vram = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                }
                //                else {
                //                    partial = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                //                    havePartial = true;
                //                }
                //            }
                //        }
                //        queuedStores += (xRn - x) >> 2;
                //        if (queuedStores > 0 && queuedSkips > 0) {
                //            vram += queuedSkips;
                //            queuedSkips = 0;
                //        }
                //        if ((xRn & 3) != 0) {
                //            if ((xRn & 0xfc) > (x & 0xfc))
                //                partial = cn & ~mask[xRn & 3];
                //            else {
                //                partial = (*vram & ~mask[x & 3]) |
                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                //            }
                //            havePartial = true;
                //        }
                //    }
                //    // Done with this colour - flush queued stores.
                //    if (queuedStores > 0) {
                //        memset(vram, cn, queuedStores);
                //        vram += queuedStores;
                //        queuedStores = 0;
                //    }

                //    x = xRn;
                //    cn = sn->_c;
                //    ++sn;
                //    xRn = sn->_x;
                //    if (x == xRo) {
                //        co = so->_c;
                //        ++so;
                //        xRo = so->_x;
                //    }

                //}




            int storeStart = 0;
            int mode = 0;  // 0 = skip, 1 = store, 2 = partial
            Byte byte = 0;
            int startByte;
            do {
                if (xRo < xRn) {
                    if (co == cn) {
                        switch (mode) {
                            case 1:
                                if ((xRo & 0xfc) > x) {
                                    // End store
                                    startByte = storeStart >> 2;
                                    memset(vram + startByte, byte, (x >> 2) - startByte);
                                    mode = 0;
                                }
                                break;
                            case 2:
                                if ((xRo & 0xfc) > x) {
                                    // End partial
                                    vram[x >> 2] = byte | (cn & mask[x & 3]);
                                    mode = 0;
                                }
                                else {
                                    // Continue partial
                                    byte |= (cn & mask[x & 3] & ~mask[xRo & 3]);
                                }
                                break;
                        }
                    }
                    else {
                        switch (mode) {
                            case 0:
                                if ((x & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc)) {
                                        Byte* p = vram + (x >> 2);
                                        *p = (*p & ~mask[x & 3]) | (cn & mask[x & 3]);
                                        x = (x + 3) & 0xfc;
                                        storeStart = x;
                                        byte = cn;
                                        mode = 1;
                                    }
                                    else {
                                        byte = (vram[x >> 2] & ~mask[x & 3]) | (cn & mask[x & 3] & ~mask[xRn & 3]);
                                        mode = 2;
                                    }
                                }
                                else {
                                    storeStart = x;
                                    mode = 1;
                                }
                                //if ((xRn & 3) != 0) {
                                //    if ((xRn & 0xfc) > (x & 0xfc))
                                //        partial = cn & ~mask[xRn & 3];
                                //    else {
                                //        partial = (*vram & ~mask[x & 3]) |
                                //            (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //    }
                                //    havePartial = true;
                                //}
                                break;
                            case 1:
                                if ((x & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc)) {
                                        Byte* p = vram + (x >> 2);
                                        *p = (*p & ~mask[x & 3]) | (cn & mask[x & 3]);
                                        x = (x + 3) & 0xfc;
                                        storeStart = x;
                                        byte = cn;
                                        mode = 1;
                                    }
                                    else {
                                        byte = (vram[x >> 2] & ~mask[x & 3]) | (cn & mask[x & 3] & ~mask[xRn & 3]);
                                        mode = 2;
                                    }
                                }
                                queuedStores += (xRo - x) >> 2;
                                if (queuedStores > 0 && queuedSkips > 0) {
                                    vram += queuedSkips;
                                    queuedSkips = 0;
                                }
                                if ((xRn & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc))
                                        partial = cn & ~mask[xRn & 3];
                                    else {
                                        partial = (*vram & ~mask[x & 3]) |
                                            (cn & mask[x & 3] & ~mask[xRn & 3]);
                                    }
                                    havePartial = true;
                                }
                                break;
                            case 2:
                                //        if ((x & 3) != 0) {
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    if (queuedSkips > 0) {
                                //                        vram += queuedSkips;
                                //                        queuedSkips = 0;
                                //                    }
                                //                    *vram = partial | (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                    havePartial = false;
                                //                }
                                //                else {
                                //                    partial |= cn &
                                //                        mask[x & 3] & ~mask[xRn & 3];
                                //                }
                                //        }
                                //        queuedStores += (xRo - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                        }
                    }
                    x = xRo;
                    co = so->_c;
                    ++so;
                    xRo = so->_x;
                }
                else {
                    if (co == cn) {
                        switch (mode) {
                            case 0:
                                // Nothing to do - end of skip moved
                                break;
                            case 1:
                                if ((xRn & 0xfc) > x) {
                                    // End store
                                    int startByte = storeStart >> 2;
                                    memset(vram + startByte, byte,
                                        (x >> 2) - startByte);
                                    mode = 0;
                                }
                                break;
                            case 2:
                                if ((xRn & 0xfc) > x) {
                                    // End partial
                                    vram[x >> 2] = byte | (cn & mask[x & 3]);
                                    mode = 0;
                                }
                                else {
                                    // Continue partial
                                    byte |=
                                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                }
                                break;
                        }
                    }
                    else {
                        switch (mode) {
                            case 0:
                                //        if ((x & 3) != 0) {
                                //                if (queuedSkips > 0) {
                                //                    vram += queuedSkips;
                                //                    queuedSkips = 0;
                                //                }
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    *vram = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                }
                                //                else {
                                //                    partial = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //                    havePartial = true;
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                            case 1:
                                //        if ((x & 3) != 0) {
                                //                if (queuedSkips > 0) {
                                //                    vram += queuedSkips;
                                //                    queuedSkips = 0;
                                //                }
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    *vram = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                }
                                //                else {
                                //                    partial = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //                    havePartial = true;
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                            case 2:
                                //        if ((x & 3) != 0) {
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    if (queuedSkips > 0) {
                                //                        vram += queuedSkips;
                                //                        queuedSkips = 0;
                                //                    }
                                //                    *vram = partial | (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                    havePartial = false;
                                //                }
                                //                else {
                                //                    partial |= cn &
                                //                        mask[x & 3] & ~mask[xRn & 3];
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                        }
                    }
                    //    // Done with this colour - flush queued stores.
                    //    if (queuedStores > 0) {
                    //        memset(vram, cn, queuedStores);
                    //        vram += queuedStores;
                    //        queuedStores = 0;
                    //    }
                    x = xRn;
                    cn = sn->_c;
                    ++sn;
                    xRn = sn->_x;
                    if (x == xRo) {
                        co = so->_c;
                        ++so;
                        xRo = so->_x;
                    }
                }
            } while (x < 0xff);
            switch (mode) {
                case 1:
                    startByte = storeStart >> 2;
                    memset(vram + startByte, byte, 0x3f - startByte);
                    break;
                case 2:
                    vram[0x3f] = byte;
            }





        void renderDeltas(Byte* vram, const Line* o) const
        {
            static const Byte mask[4] = {0xff, 0x3f, 0x0f, 0x03};

            const Span* sn = _s;
            const Span* so = o->_s;
            int x = 0;
            int cn = sn->_c;
            ++sn;
            int xRn = sn->_x;
            int co = so->_c;
            ++so;
            int xRo = so->_x;

            bool havePartial = false;
            Byte c = cn;
            bool transparent = true;
            int storeL = 0;
            int storeR = 0;

            do {
                if (xRo < xRn) {
                    if (co == cn) {
                        if (!transparent) {
                            storeR = x;
                            transparent = true;
                        }
                    }
                    else {
                        if (transparent) {
                            if (c != cn || (x & 0xfc) > (storeR & 0xfc) + 4) {
                                int byteL = storeL >> 2;
                                memset(vram + byteL, c, (storeR >> 2) - byteL);
                                storeL = x;
                                c = cn;
                            }
                            transparent = false;
                        }
                    }
                    x = xRo;
                    co = so->_c;
                    ++so;
                    xRo = so->_x;
                }
                else {
                    if (co == cn) {
                        if (!transparent) {
                            storeR = x;
                            transparent = true;
                        }
                    }
                    else {
                        if (transparent) {
                            if (c != cn || (x & 0xfc) > (storeR & 0xfc) + 4) {
                                int byteL = storeL >> 2;
                                memset(vram + byteL, c, (storeR >> 2) - byteL);
                                storeL = x;
                                c = cn;
                            }
                            transparent = false;
                        }
                        else {
                            if (cn != c) {
                                int byteL = storeL >> 2;
                                memset(vram + byteL, c, (storeR >> 2) - byteL);
                                storeL = x;
                                c = cn;
                            }
                        }
                    }
                    x = xRn;
                    cn = sn->_c;
                    ++sn;
                    xRn = sn->_x;
                    if (x == xRo) {
                        co = so->_c;
                        ++so;
                        xRo = so->_x;
                    }
                }
            } while (x < 0xff);
            if (!transparent)
                storeR = x;
            int byteL = storeL >> 2;
            memset(vram + byteL, (storeR >> 2) - byteL);



Convert sn and so into sequence of (X, C?)
  Possible transitions:
    colour to different colour on byte boundary
    colour to different colour not on byte boundary
    colour to transparent on byte boundary
    colour to transparent not on byte boundary
    transparent to colour on byte boundary
    transparent to colour not on byte boundary




            bool havePartial = false;
            Byte partial;
            do {
                if ((xRn & 0xfc) == (xLn & 0xfc)) {
                    if (cn != co) {
                        Byte newBits = cn & mask[xLn & 3] & ~mask[xRo & 3];
                        if (!havePartial) {
                            if ((xLn & 3) == 0)
                                partial = 0;
                            else
                                partial = vram[xLn >> 2] & ~mask[xLn & 3];
                            havePartial = true;
                        }
                        partial |= newBits;
                    }
                }
                else {
                    if (cn != co) {
                        if (!havePartial)
                            partial = vram[xLn >> 2] & ~mask[xLn & 3];
                        vram[xLn >> 2] = partial | (cn & mask[xLn & 3]);
                    }
                    else {
                        if (havePartial)
                            vram[xLn >> 2] = partial | (cn & mask[xLn & 3]);
                    }
                    xLn = (xLn + 3) & 0xfc;
                    int storeStart = xLn;
                    int storeEnd = xLn;
                    bool store = false;
                    if (xLo < xLn)
                        xLo = xLn;   // TODO: do we need this?
                    do {
                        if (store) {
                            if (cn == co) {
                                storeEnd = xLo;
                                store = false;
                            }
                        }
                        else {
                            if (cn != co) {
                                if ((xLo & 0xfc) > (storeEnd & 0xfc) + 4) {
                                    if (storeStart < storeEnd) {
                                        int startByte = storeStart >> 2;
                                        memset(vram + startByte, cn, (storeEnd >> 2) - startByte);
                                    }
                                    storeStart = xLo;
                                }
                                store = true;
                            }
                        }
                        if (xRo >= xRn)
                            break;
                        xLo = xRo;
                        co = so->_c;
                        ++so;
                        xRo = so->_x;
                    } while (true);
                    if (store)
                        storeEnd = xRn;
                    if (storeStart < storeEnd) {
                        int startByte = storeStart >> 2;
                        memset(vram + startByte, cn, (storeEnd >> 2) - startByte);
                    }
                    if ((xRn & 3) != 0) {
                        partial = cn & ~mask[xRn & 3];
                        havePartial = true;
                    }
                    else
                        havePartial = false;
                }
                xLn = xRn;
                cn = sn->_c;
                ++sn;
                xRn = sn->_x;
                if (xRo == xLn) {
                    xLo = xRo;
                    co = so->_c;
                    ++so;
                    xRo = so->_x;
                }
            } while (xLn < 0xff);




0x00000021  y == 0x20

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:
0x002EE13C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x002EE14C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x002EE15C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x002EE16C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x0030E08C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0030E09C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0030E0AC  55 55 55 40 00 00 00 00 00 00 00 54 00 00 00 00  UUU@.......T....
0x0030E0BC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x00307770  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x00307780  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x00307790  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x003077A0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0x2d
  xLo = 0x00, co = 0x00, xRo = 0x2d - no actions
xLn = 0x2d, cn = 0x55, xRn = 0x8d
  xLn = 0x30
  xLo = 0x30, co = 0x55, xRo = 0xaf - no actions
xLn = 0x8d, cn = 0x00, xRn = 0xff
  partial = 0x40, set to vram
  xLn = 0x90
  xLo = 0x90, co = 0x55, xRo = 0xaf - no actions
  xLo = 0xaf, co = 0x00, xRo = 0xff
  store 0x90 - 0xaf

The region 8d->af is non-transparent (c = 0)
The transition af is non-transparent (c = 0) to transparent (co = 0)
  We should start a new partial


0x000003ce  y = 0xad

old: 00 00 ff
new: 00 00 c9 55 ca 00 ff

Previous:
0x0036F7EC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0036F7FC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0036F80C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0036F81C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x0016F38C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0016F39C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0016F3AC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0016F3BC  00 00 14 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x00167484  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x00167494  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x001674A4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x001674B4  00 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0xc9
  xLo = 0x00, co = 0x00, xRo = 0xff


0x000008b7  y = 0x1e

old: 00 00 2d 55 2e 00 ff
new: 00 00 2d 55 2e 00 ff

Previous:
0x0038BBEC  00 00 00 00 00 00 00 00 00 00 00 10 00 00 00 00  ................
0x0038BBFC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0038BC0C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0038BC1C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x003CC104  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003CC114  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003CC124  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003CC134  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x003C782C  00 00 00 00 00 00 00 00 00 00 00 10 00 00 00 00  ................
0x003C783C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003C784C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003C785C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0x2d
  xLo = 0x00, co = 0x00, xRo = 0x2d
xLn = 0x2d, cn = 0x55, xRn = 0x2e
  xLo = 0x2d, co = 0x55, xRo = 0x2e
xLn = 0x2e, cn = 0x00, xRn = 0xff
  xLo = 0x2e, co = 0x00, xRo = 0xff


0x0000055e

old: 00 00 c6 55 c8 00 ff
new: 00 00 b7 55 c7 00 ff

Previous:
0x003AF68C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003AF69C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003AF6AC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003AF6BC  00 05 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x002CF37C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x002CF38C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x002CF39C  00 00 00 00 00 00 00 00 00 00 00 00 00 01 55 55  ..............UU
0x002CF3AC  55 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00  U...............

vram2:
0x002C7474  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x002C7484  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x002C7494  00 00 00 00 00 00 00 00 00 00 00 00 00 01 55 55  ..............UU
0x002C74A4  55 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00  UT..............        wrong from c4 to c6

xLn = 0x00, cn = 0x00, xRn = 0xb7
  xLo = 0x00, co = 0x00, xRo = 0xc6       00->b7
xLn = 0xb7, cn = 0x55, xRn = 0xc7
  xLo = 0x00, co = 0x00, xRo = 0xc6       b7->c6
  xLo = 0xc6, co = 0x55, xRo = 0xc8       c6->c7
xLn = 0xc7, cn = 0x00, xRn = 0xff
  xLo = 0xc6, co = 0x55, xRo = 0xc8       c7->c8
  xLo = 0xc8, co = 0x00, xRo = 0xff       c8->ff


0x0000272a

old: 00 00 66 aa 67 00 ff
new: 00 00 66 aa 69 00 ff

Previous:
0x0016DEEC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0016DEFC  00 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00  ................
0x0016DF0C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0016DF1C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x0032E16C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................      64 65 66 67
0x0032E17C  00 00 00 00 00 00 00 00 00 08 80 00 00 00 00 00  ..........?.....      00 00 10 00   pixel 67 wrong
0x0032E18C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0032E19C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x00327984  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x00327994  00 00 00 00 00 00 00 00 00 0a 80 00 00 00 00 00  ..........?.....      00 00 10 10
0x003279A4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003279B4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0x66
  xLo = 0x00, co = 0x00, xRo = 0x66
xLn = 0x66, cn = 0xaa, xRn = 0x69
  xLo = 0x66, co = 0xaa, xRo = 0x67
  xLo = 0x67, co = 0x00, xRn = 0xff   Need to


0x00000021

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

vram0:
0x0039C2B4  00 00 00 00 00 00 00 00 00 00 00 55 55 55 55 55  ...........UUUUU
0x0039C2C4  55 55 40 00 00 00 00 00 00 00 00 00 00 00 00 00  UU@.............
0x0039C2D4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0039C2E4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x00357A6C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x00357A7C  55 55 40 00 00 00 00 00 00 00 00 00 00 00 00 00  UU@.............
0x00357A8C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x00357A9C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................


0x2a47

old: 00 00 67 aa 6a 00 ff
new: 00 00 68 aa 6b 00 ff

Previous:
0x0028C0AC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0028C0BC  00 00 00 00 00 00 00 00 00 02 a0 00 00 00 00 00  ..........ÿ.....
0x0028C0CC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0028C0DC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x003CBEEC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  68 69 6a 6b
0x003CBEFC  00 00 00 00 00 00 00 00 00 00 a0 00 00 00 00 00  ..........ÿ.....  10 10 00 00    6a is wrong
0x003CBF0C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003CBF1C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x003C7754  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003C7764  00 00 00 00 00 00 00 00 00 00 a8 00 00 00 00 00  ..........ù.....  10 10 10 00
0x003C7774  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003C7784  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0x68
  xLo = 0x00, co = 0x00, xRo = 0x67
  xLo = 0x67, co = 0xaa, xRo = 0x6a
xLn = 0x68, cn = 0xaa, xRn = 0x6b
  xLo = 0x67, co = 0xaa, xRo = 0x6a
  xLo = 0x6a, co = 0x00, xRo = 0xff
xLn = 0x6b, co = 0xaa, xRn = 0xff
  xLo = 0x6a, co = 0x00, xRo = 0xff

distance = 16/15
distance/sqrt(1 + distance*distance) = 0.7295372041400851165587716156716 = d
cubeScale = d/sqrt(3) = 0.42119850119412510580103372768878 = 107
octahedronScale = d = 186

phi = (sqrt(5)+1)/2 = 1.6180339887498948482045868343656
icosahedronScale = d/sqrt(phi*phi + 1) = 1.3876622237543512773832507566044 = 98
phi*icosahedronScale = 0.62058141242465057745887948393161 = 158

phi*cubeScale = 0.42119850119412510580103372768878 = 174
(phi-1)*cubeScale = 0.26031498974848248742610274195249 = 66

s.x = 99.5 * 6/5 * 16/15 = 127.36 = 32604 = 0x7F5C
s.y = 99.5 * 16/15 = 106.133 = 27170 = 0x6A22
s.z = 0x100



Orientation check when screen coordinates are in 24.8 format:
  Note that if an odd number of transformed-z coordinates are <0 then we need to reverse the result of the test
  Want to avoid doing 4 muls instead of 1 if at all possible
    (xH:xL)*(yH:yL) = (xH*yH)H : (xH*yH)L :     0000 :     0000
                          0000 : (xH*yL)H : (xH*yL)L :     0000
                          0000 : (xL*yH)H : (xL*yH)L :     0000
                          0000 :     0000 : (xL*yL)H : (xL*yL)L
    Instead of computing the normal of the screen-space triangle,
      store a normal vector for each face in the model
      transform it as if it was a world coordinate (but only compute the z component)
      look at the sign of the z component
      This is 3 muls instead of 4
    Compute the vectors (x1-x0,y1-y0) and (x2-x0,y2-y0)
      Compute atan2 of these vectors, subtract and figure out if result is < or > than 180 degrees
        Normalization is the issue here - the multiplies take care of that
        Could do it by division instead, but 16.16/16.16 isn't any better
    The orientation check doesn't need to be perfect - once we have depth sorting, there's no correctness issue if we plot some faces we should omit
      The check needs to be conservative - want to avoid omitting faces we should plot
      Can just use top halves of post-rotation, pre-projection x and y coordinates (ignoring subpixels)
        This doesn't work - projection can change the orientation of a face



screen is 178mm tall and 190mm wide (pixels 740um by 889um, subpixels 2.89um by 3.47um)




Tricky optimizations:

2D equivalent of span buffers
  Go directly to binary space partitioning:
    256x200  256x128 (256x72)  128x128 (128x72)  128x64  64x64  64x32  32x32  32x16  16x16  16x8  8x8  8x4  4x4  4x2  4x1
    Each node can be
      solid colour             - high byte 0, low byte colour
      one line passing through - pointer to: colour 1, colour 2, pointer to vertex A, pointer to vertex B (can be shared by multiple nodes). Maybe also some cached intersection data?
      subdivide to next level  - pointer to: upper/left child, lower/right child
    Delta algorithm:
      1 solid colour -> solid colour (same)            : nothing to do
      2 solid colour -> solid colour (different)       : fill rectangle
      3 solid colour -> one line (one colour same)     : trapezoid plus 0 or 1 rectangles
      4 solid colour -> one line (no colours same)     : trapezoid plus 0, 1 or 2 rectangles
      5 solid colour -> subdivide                      : recurse
      6 one line     -> solid colour (one colour same) : crude trapezoid
      7 one line     -> solid colour (no colours same) : fill rectangle
      8 one line     -> one line (no colours same)     : same as case 4
      9 one line     -> one line (one colour same)     : (crude) trapezoids and/or rectangles
     10 one line     -> one line (two colours same)    : (crude) trapezoids and/or rectangles
     11 one line     -> subdivide                      : recurse
     12 subdivide    -> solid colour                   : recurse
     13 subdivide    -> one line                       : recurse
     14 subdivide    -> subdivide                      : recurse
    Need to be able to take a one-line node and subdivide it
      The result is either a solid-colour node or a one-line node
      Given two vertices and a rectangle, need a quick way to determine if line intersects it
        Evaluate line equation at corners?
        Shortcuts
      Use shifts to determine intersection point with center line, given intersection points with top and bottom lines
    Algorithm for drawing a triangle in a BSP buffer
      If any of the vertices is inside the block, subdivide it
      If block is one-line
        If triangle covers up old line
          Replace line with our line
        otherwise, subdivide
      If entire block is inside triangle, replace with solid-colour
    Re-use of blocks
      Each buffer has its own set of block pools
      There's a block pool for each type of block (subdivide, one-line)
      Free blocks are arranged into lists
        When we need a new block, take the first one from the free list
      When freeing a one-line block, just add it to the free list (re-use colour bytes as next-free pointer)
      Subdivision block needs to have a next-in-free-list pointer (empty when in use)
      When freeing a subdivision block, use next-in-free-list pointer to add to queue
      When we need a new subdivision block, free any child blocks when removing block from free list

Eliminating excess transforms
  Faces and vertices have "visible" flags
    A face is visible if any part of it is on screen (even if none of its vertices are visible)
      Either at least one vertex must be visible or the triangle contains a screen corner
    A vertex is visible if it transforms to a point on the screen
  Clear all "visible" flags for this frame (alternate between sets of flags)
  In the course of the following, fill in "transformed" and "visible" flags for each vertex as we compute them
  Find a visible triangle
    Try triangles that were visible last frame first
    Process it
  Processing a triangle:
    Mark it as visible
    Look for adjacent triangles and add them to the "possibly visible triangles" list
  For each triangle in possibly visible triangles list
    Figure out if it is visible and process it if it is
This algorithm works well for the background but less well for foreground objects
  If we know an object is visible we can process it the same way
  Eliminating an object from consideration is more difficult - need to intersect bounding spheres with the viewing frustrum

Can we do the perspective transform with a single-precision 32/16->16 divide instead of a double-precision 32/16->32 divide?
  Quotient would have to be pixel precision (16.0)
    This is not too bad, but a little jerky especially when moving slowly
      So perhaps we can use 16-bit quotients when moving fast and 32-bit quotients when moving slowly
  Divisor needs to be 0x100 for near plane (8.8)
  Therefore dividend would be 24.8 in range -0x007fff.ff to 0x7fff.ff (so no ~127 multiplier in matrix)
    However, that would overflow if -0x100 < z < 0x100
      For these points, we can assume that they are not visible. Can also assume that no two such points connect with a visible edge, since that edge would have to pass through the ship
      For each edge that connects it to an on-screen point, need to find the slope of the line (the intersect is given by the visible point)
  We need to treat z=0 specially anyway, so lets similarly treat near-points specially
    If x/z does not overflow, we don't want to use the point at infinity
      Hook interrupt 0 to find out when overflow happens?

Optimizations that aren't particularly tricky but which reduce output fidelity:
  ISAV mode
  Reduce horizontal resolution to 128 or 64 columns



Collision detection:
  Initially assume ship is spherical for collision-detection purposes
    Same for enemies, items etc.
  For each object we might collide with (including background) have a BSP tree
    Do we really want BSP trees for enemies if the enemy is treated as a sphere for collisions with the background?
    Colliding one non-sphere with another non-sphere seems like it would get too complicated too quickly
      Non-spherical enemies should avoid colliding with each other and with background (move along fixed paths?)
      Spherical bullets should just disappear on contact with background or enemy or player
      Collision between player and enemy results kills player
  Move all objects according to their velocity, then check for collisions
    It's much easier if a spherical object can't move more than its own radius per frame (r = 463 for ship, crossing room in 71 frames or 1.2 seconds)
  Update BSP node for each object
    while (!object.inside(node))
        node = node.parent();
    while (node.isSubdivide())
        node = node.childContaining(object);
  BSP node is one of:
    subdivide
    face
    convex edge
    convex corner
    concave edge
    concave corner
  Instead of partitioning space into two equally-sized blocks, avoid splitting nodes that don't need to be split
    But also want to avoid having to do excess multiplications to see which child node to go to
      Not sure how bad those multiplications would be in practice - 3 per node descent but most frames we'll be in the same node
  In general there may be 2 or even 3 faces we're colliding with at once
    These regions have their own nodes, but once the collision is resolved we're on the intersection of two or three nodes (which shouldn't be a problem)
  Given position, velocity and node details, compute new position and velocity (sliding along face or concave edge if necessary)
